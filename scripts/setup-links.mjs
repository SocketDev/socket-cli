#!/usr/bin/env node

/**
 * @fileoverview Setup local development linking for Socket projects.
 * Generates .pnpmfile.cjs files (gitignored) for local development only.
 *
 * In CI/production, these files don't exist, so pnpm uses normal package.json dependencies.
 */

import { spawn } from '@socketsecurity/registry/lib/spawn'
import { existsSync } from 'node:fs'
import { mkdir, writeFile } from 'node:fs/promises'
import { dirname, join, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'

const __dirname = dirname(fileURLToPath(import.meta.url))
const projectRoot = resolve(__dirname, '..')
const parentDir = resolve(projectRoot, '..')

// What each project can link to.
const LINK_CONFIG = {
  'socket-cli': {
    '@socketsecurity/registry': {
      localPath: '../socket-registry/registry',
      gitRepo: 'SocketDev/socket-registry',
    },
    '@socketsecurity/sdk': {
      localPath: '../socket-sdk-js',
      gitRepo: 'SocketDev/socket-sdk-js',
    },
  },
  'socket-sdk-js': {
    '@socketsecurity/registry': {
      localPath: '../socket-registry/registry',
      gitRepo: 'SocketDev/socket-registry',
    },
  },
  'socket-packageurl-js': {
    '@socketsecurity/registry': {
      localPath: '../socket-registry/registry',
      gitRepo: 'SocketDev/socket-registry',
    },
  },
}

const SOCKET_PROJECTS = Object.keys(LINK_CONFIG)

/**
 * Generate .pnpmfile.cjs content for a project.
 */
function generatePnpmFile(projectName, mode = 'local') {
  const config = LINK_CONFIG[projectName]
  if (!config) {
    return null
  }

  const overrides = []

  for (const [pkg, info] of Object.entries(config)) {
    if (mode === 'local') {
      overrides.push(
        `    pkg.pnpm.overrides['${pkg}'] = 'link:\${path.resolve(__dirname, '${info.localPath}')}'`,
      )
    } else if (mode === 'main') {
      overrides.push(
        `    pkg.pnpm.overrides['${pkg}'] = 'github:${info.gitRepo}#main'`,
      )
    }
    // published mode = no overrides needed
  }

  if (overrides.length === 0 && mode === 'published') {
    return null // No file needed for published mode
  }

  return `/**
 * @fileoverview PNPM configuration for local development.
 * This file is generated by scripts/setup-links.mjs and is gitignored.
 * CI/production uses published npm packages (no overrides).
 */

const path = require('path')

function readPackage(pkg, context) {
  // Only process our package.json
  if (pkg.name !== '${projectName === 'socket-cli' ? 'socket' : `@socketsecurity/${projectName.replace('socket-', '')}`}') return pkg

  pkg.pnpm = pkg.pnpm || {}
  pkg.pnpm.overrides = pkg.pnpm.overrides || {}

${overrides.join('\n')}

  console.log('ðŸ”— Using ${mode} mode for dependencies')
  return pkg
}

module.exports = {
  hooks: {
    readPackage
  }
}
`
}

/**
 * Clone a dependency if it doesn't exist.
 */
async function cloneDependency(name, gitRepo) {
  const targetPath = gitRepo.includes('registry')
    ? join(parentDir, 'socket-registry')
    : join(parentDir, name.split('/')[1].replace('sdk', 'sdk-js'))

  if (existsSync(targetPath)) {
    console.log(`âœ“ ${name} found at: ${targetPath}`)
    return true
  }

  console.log(`ðŸ“¦ Cloning ${name} from GitHub...`)

  try {
    await spawn(
      'git',
      ['clone', `https://github.com/${gitRepo}.git`, targetPath],
      {
        stdio: 'inherit',
        cwd: parentDir,
      },
    )

    // Install dependencies
    const installPath = gitRepo.includes('registry')
      ? join(targetPath, 'registry')
      : targetPath

    console.log(`ðŸ“¦ Installing ${name} dependencies...`)
    await spawn('pnpm', ['install'], {
      stdio: 'inherit',
      cwd: installPath,
    })

    console.log(`âœ“ ${name} ready`)
    return true
  } catch (error) {
    console.error(`âœ— Failed to clone ${name}:`, error)
    return false
  }
}

/**
 * Check if a Socket project exists.
 */
function projectExists(projectName) {
  const projectPath = join(parentDir, projectName)
  return existsSync(join(projectPath, 'package.json'))
}

/**
 * Get list of available Socket projects.
 */
function getAvailableProjects() {
  return SOCKET_PROJECTS.filter(projectExists)
}

/**
 * Setup linking for projects.
 */
async function setupLinks(mode = 'local', projects = SOCKET_PROJECTS) {
  const results = []

  // For local mode, ensure dependencies exist
  if (mode === 'local') {
    const deps = new Set()
    for (const project of projects) {
      const config = LINK_CONFIG[project]
      if (config) {
        for (const [pkg, info] of Object.entries(config)) {
          deps.add(`${pkg}|${info.gitRepo}`)
        }
      }
    }

    for (const dep of deps) {
      const [pkg, gitRepo] = dep.split('|')
      const localPath = LINK_CONFIG[projects[0]][pkg]?.localPath
      if (localPath && !existsSync(join(parentDir, localPath.split('/')[1]))) {
        const success = await cloneDependency(pkg, gitRepo)
        if (!success) {
          console.log(
            `âš  Failed to setup ${pkg}, falling back to published mode`,
          )
          mode = 'published'
          break
        }
      }
    }
  }

  // Generate .pnpmfile.cjs for each project
  for (const project of projects) {
    if (!projectExists(project)) {
      console.log(`âš  Skipping ${project} (not found)`)
      continue
    }

    const content = generatePnpmFile(project, mode)
    const filePath = join(parentDir, project, '.pnpmfile.cjs')

    if (content) {
      await writeFile(filePath, content)
      console.log(`âœ“ ${project}: Created .pnpmfile.cjs (${mode} mode)`)
    } else if (existsSync(filePath)) {
      // Remove file for published mode
      const { unlink } = await import('node:fs/promises')
      await unlink(filePath)
      console.log(
        `âœ“ ${project}: Removed .pnpmfile.cjs (using published packages)`,
      )
    } else {
      console.log(`âœ“ ${project}: Using published packages (no overrides)`)
    }

    results.push(project)
  }

  return results
}

/**
 * Display usage information.
 */
function showHelp() {
  const available = getAvailableProjects()
  console.log(`
Socket Development Linking Setup

This tool creates local .pnpmfile.cjs files (gitignored) for development.
CI/production will use published npm packages (no .pnpmfile.cjs).

Usage: node scripts/setup-links.mjs [mode] [options]

Modes:
  local      Link to local filesystem (default)
  main       Use GitHub main branches
  published  Use published npm packages (removes .pnpmfile.cjs)
  off        Same as published

Options:
  --all      Apply to all Socket projects
  --help     Show this help

Projects found:
  ${available.map(p => `âœ“ ${p}`).join('\n  ') || 'None'}

Examples:
  # Setup local development (default)
  node scripts/setup-links.mjs

  # Use GitHub main branches
  node scripts/setup-links.mjs main --all

  # Reset to published packages
  node scripts/setup-links.mjs published --all

  # Setup specific project
  node scripts/setup-links.mjs local socket-cli
`)
}

/**
 * Main entry point.
 */
async function main() {
  const args = process.argv.slice(2)

  if (args.includes('--help') || args.includes('-h')) {
    showHelp()
    process.exit(0)
  }

  // Parse mode
  let mode = 'local'
  if (['local', 'main', 'published', 'off'].includes(args[0])) {
    mode = args[0] === 'off' ? 'published' : args[0]
  }

  // Parse projects
  let projects = []
  if (args.includes('--all')) {
    projects = getAvailableProjects()
  } else {
    // Get project names from args
    for (const arg of args) {
      if (SOCKET_PROJECTS.includes(arg)) {
        projects.push(arg)
      }
    }
    // Default to current project or all
    if (projects.length === 0) {
      const currentProject = dirname(projectRoot).split('/').pop()
      if (SOCKET_PROJECTS.includes(currentProject)) {
        projects = [currentProject]
      } else {
        projects = getAvailableProjects()
      }
    }
  }

  if (projects.length === 0) {
    console.error('âœ— No Socket projects found')
    showHelp()
    process.exit(1)
  }

  console.log(`\nðŸ”§ Setting up ${mode} linking for: ${projects.join(', ')}\n`)

  const configured = await setupLinks(mode, projects)

  if (configured.length > 0) {
    console.log(`\nðŸ“¦ Running pnpm install to apply changes...\n`)

    for (const project of configured) {
      const projectPath = join(parentDir, project)
      console.log(`Installing ${project}...`)

      await spawn('pnpm', ['install'], {
        stdio: 'inherit',
        cwd: projectPath,
      })
    }

    console.log(`\nâœ“ Setup complete! Using ${mode} mode for:`)
    console.log(`  ${configured.join('\n  ')}\n`)
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(error => {
    console.error('âœ— Setup failed:', error)
    process.exit(1)
  })
}

export { setupLinks, generatePnpmFile }
