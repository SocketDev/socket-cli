import { handleGitHubApiError, withGitHubRetry } from './git/github.mjs'

import type { CResult } from '../types.mjs'

// 30 days in milliseconds for CVE to GHSA cache.
const THIRTY_DAYS_MS = 30 * 24 * 60 * 60 * 1000

/**
 * Converts CVE IDs to GHSA IDs using GitHub API.
 * CVE to GHSA mappings are permanent, so we cache for 30 days.
 */
export async function convertCveToGhsa(
  cveId: string,
): Promise<CResult<string>> {
  // Use dynamic import to avoid circular dependency with cacheFetch.
  const { cacheFetch, getOctokit } = await import('./git/github.mjs')

  const cacheKey = `cve-to-ghsa-${cveId}`

  // Check cache first before making API call.
  try {
    const octokit = getOctokit()

    const response = await cacheFetch(
      cacheKey,
      async () => {
        const result = await withGitHubRetry(
          () =>
            octokit.rest.securityAdvisories.listGlobalAdvisories({
              cve_id: cveId,
              per_page: 1,
            }),
          `converting CVE ${cveId} to GHSA`,
        )

        if (!result.ok) {
          throw result
        }

        return result.data
      },
      THIRTY_DAYS_MS,
    )

    if (!response.data.length) {
      return {
        ok: false,
        message: `No GHSA found for CVE ${cveId}`,
      }
    }

    const ghsaId = response.data[0]?.ghsa_id
    if (!ghsaId) {
      return {
        ok: false,
        message: `No GHSA ID found in response for CVE ${cveId}`,
      }
    }

    return {
      ok: true,
      data: ghsaId,
    }
  } catch (e) {
    // If the error is already a CResult, return it directly.
    if (e && typeof e === 'object' && 'ok' in e && (e as any).ok === false) {
      return e as CResult<string>
    }

    // Otherwise, convert the error to a user-friendly message.
    return handleGitHubApiError(e, `converting CVE ${cveId} to GHSA`)
  }
}
