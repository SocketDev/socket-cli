/**
 * Extract yoga-layout WASM base64 and create yoga-sync.mjs
 * This runs during build to extract the WASM binary from yoga-layout
 * and generate our custom synchronous loader wrapper.
 *
 * Idempotent: Skips regeneration if source hasn't changed (supports CI caching).
 */

import { readFileSync, writeFileSync } from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

import {
  ensureOutputDir,
  generateHashComment,
  shouldExtract,
} from '@socketsecurity/build-infra/lib/extraction-cache'
import { logger } from '@socketsecurity/lib/logger'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const rootPath = path.join(__dirname, '..')

const outputPath = path.join(rootPath, 'build/yoga-sync.mjs')

// Source files from custom yoga-layout package.
const yogaPackageRoot = path.join(rootPath, '../yoga-layout')
const yogaWasmFile = path.join(yogaPackageRoot, 'build/yoga.wasm')
const yogaJsFile = path.join(yogaPackageRoot, 'build/yoga.js')

// Check if extraction needed (hash ALL source files).
if (!await shouldExtract({
  sourcePaths: [yogaWasmFile, yogaJsFile],
  outputPath,
  validateOutput: (content) =>
    content.includes('yoga-layout') &&
    content.includes('WebAssembly'),
})) {
  process.exit(0)
}

// Read WASM binary and convert to base64.
const wasmBinary = readFileSync(yogaWasmFile)
const base64Data = wasmBinary.toString('base64')

// Compute source hash for cache validation (hashes all source files).
const sourceHashComment = await generateHashComment([
  yogaWasmFile,
  yogaJsFile,
])

logger.log(
  `✓ Extracted ${wasmBinary.length} bytes of WASM data from custom yoga-layout`,
)

// Read the yoga.js loader code to inline it.
const yogaJsContent = readFileSync(yogaJsFile, 'utf-8')

// Generate yoga-sync.mjs with inlined WASM and loader - synchronous proxy.
const yogaSyncContent = `/**
 * Synchronous yoga-layout with embedded WASM binary.
 *
 * This file is AUTO-GENERATED by scripts/extract-yoga-wasm.mjs
 * DO NOT EDIT MANUALLY - changes will be overwritten on next build.
 *
 * Uses a Proxy to lazily initialize yoga on first property access.
 * The initialization happens synchronously using WebAssembly.instantiate().
 *
 * ${sourceHashComment}
 */

// Inlined base64 WASM from custom yoga-layout (extracted at build time).
const base64Wasm = '${base64Data}'

// Decode base64 to Uint8Array.
const wasmBinary = Uint8Array.from(atob(base64Wasm), c => c.charCodeAt(0))

// Inlined Emscripten loader from custom yoga-layout build.
${yogaJsContent}

// Lazily initialized yoga instance.
let yogaInstance = null
let initPromise = null

// Initialize yoga (happens once on first access).
function initYoga() {
  if (yogaInstance) {
    return yogaInstance
  }

  if (!initPromise) {
    initPromise = createYogaModule({
      wasmBinary,
      instantiateWasm(imports, successCallback) {
        const module = new WebAssembly.Module(wasmBinary)
        const instance = new WebAssembly.Instance(module, imports)
        successCallback(instance, module)
        return instance.exports
      }
    }).then(yoga => {
      yogaInstance = yoga
      return yoga
    })
  }

  // Block until initialization completes (synchronous wait).
  if (!yogaInstance) {
    throw new Error('Yoga must be initialized asynchronously before use. Import yoga-layout at module level.')
  }

  return yogaInstance
}

// Create a Proxy that forwards all property access to the yoga instance.
const yogaProxy = new Proxy({}, {
  get(target, prop) {
    const yoga = initYoga()
    return yoga[prop]
  },
  has(target, prop) {
    const yoga = initYoga()
    return prop in yoga
  }
})

export default yogaProxy
`

ensureOutputDir(outputPath)
writeFileSync(outputPath, yogaSyncContent, 'utf-8')

logger.log(`✓ Generated ${outputPath}`)
logger.log(`✓ yoga-sync.mjs size: ${yogaSyncContent.length} bytes`)
