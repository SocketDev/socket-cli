/**
 * Yoga Layout WASM Adapter (Taffy-based)
 *
 * Provides Yoga-compatible API layer on top of Taffy (pure Rust flexbox engine).
 * This adapter enables drop-in replacement for applications using Yoga Layout,
 * particularly Ink (https://github.com/vadimdemedes/ink).
 *
 * Architecture:
 * - Rust: Taffy v0.6.0 flexbox layout engine (src/lib.rs)
 * - WASM: Compiled with wasm-bindgen for JavaScript interop
 * - Adapter: This layer provides Yoga API compatibility (fills gaps in WASM bindings)
 *
 * References:
 * - Yoga Layout: https://yogalayout.dev/
 * - Taffy: https://github.com/DioxusLabs/taffy
 * - WASM Bindgen: https://rustwasm.github.io/wasm-bindgen/
 */

import { readFile } from 'node:fs/promises'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// Import WASM bindings generated by wasm-bindgen.
// Note: This assumes yoga.wasm and yoga.js are in ../build/wasm/.
const wasmPath = path.join(__dirname, '../build/wasm/yoga.wasm')

let wasmModule = null
let YogaNode = null

/**
 * Load WASM module.
 * This must be called before using any Yoga functionality.
 *
 * @returns {Promise<void>}
 */
async function loadWasm() {
  if (wasmModule) {
    return
  }

  const wasmBuffer = await readFile(wasmPath)
  const wasmImports = {}

  const { instance } = await WebAssembly.instantiate(wasmBuffer, wasmImports)
  wasmModule = instance
  YogaNode = instance.exports.YogaNode
}

/**
 * Yoga Config wrapper.
 *
 * Provides configuration for Yoga layout calculations.
 * Note: Taffy doesn't have an equivalent config system, so this is a stub
 * that maintains API compatibility but doesn't affect layout calculations.
 *
 * Reference: https://yogalayout.dev/docs/api/config
 */
class YogaConfig {
  constructor() {
    // Stub: Taffy doesn't require config objects.
    this._useWebDefaults = false
  }

  /**
   * Free config resources (no-op in WASM).
   */
  free() {
    // No-op: Garbage collection handles memory.
  }

  /**
   * Enable/disable web defaults.
   *
   * @param {boolean} useWebDefaults - Whether to use web defaults
   */
  setUseWebDefaults(useWebDefaults) {
    this._useWebDefaults = useWebDefaults
  }

  /**
   * Check if web defaults are enabled.
   *
   * @returns {boolean}
   */
  useWebDefaults() {
    return this._useWebDefaults
  }

  /**
   * Set point scale factor.
   * Note: Taffy doesn't support point scaling.
   *
   * @param {number} _factor - Scale factor (ignored)
   */
  setPointScaleFactor(_factor) {
    // No-op: Taffy doesn't support point scaling.
  }

  /**
   * Enable/disable experimental feature.
   * Note: Taffy doesn't have experimental features flag.
   *
   * @param {number} _feature - Feature enum value (ignored)
   * @param {boolean} _enabled - Whether to enable (ignored)
   */
  setExperimentalFeatureEnabled(_feature, _enabled) {
    // No-op: Taffy doesn't have experimental features.
  }

  /**
   * Check if experimental feature is enabled.
   *
   * @param {number} _feature - Feature enum value (ignored)
   * @returns {boolean} Always false
   */
  isExperimentalFeatureEnabled(_feature) {
    return false
  }

  /**
   * Set errata flags.
   * Note: Taffy doesn't have errata flags.
   *
   * @param {number} _errata - Errata flags (ignored)
   */
  setErrata(_errata) {
    // No-op: Taffy doesn't have errata flags.
  }

  /**
   * Get errata flags.
   *
   * @returns {number} Always 0
   */
  getErrata() {
    return 0
  }
}

/**
 * Yoga Node wrapper.
 *
 * Wraps the WASM YogaNode and provides full Yoga API compatibility.
 * This includes methods not directly implemented in Rust/WASM.
 *
 * Reference: https://yogalayout.dev/docs/api/node
 */
class YogaNodeWrapper {
  constructor(config = null) {
    if (!wasmModule) {
      throw new Error('WASM not loaded. Call loadWasm() first.')
    }

    // Create underlying WASM node.
    this._node = new YogaNode()
    this._config = config
    this._children = []
    this._parent = null
    this._measureFunc = null
    this._dirtiedFunc = null
    this._isDirty = true
    this._hasNewLayout = false
  }

  // ==========================================================================
  // Tree management
  // ==========================================================================

  /**
   * Insert a child node at the specified index.
   *
   * Note: Taffy's add_child() appends children and doesn't support indexed
   * insertion. This wrapper maintains a children array to track insertion order.
   *
   * @param {YogaNodeWrapper} child - Child node to insert
   * @param {number} index - Index at which to insert
   */
  insertChild(child, index) {
    this._children.splice(index, 0, child)
    child._parent = this
    this._node.insertChild(child._node, index)
    this.markDirty()
  }

  /**
   * Remove a child node.
   *
   * @param {YogaNodeWrapper} child - Child node to remove
   */
  removeChild(child) {
    const index = this._children.indexOf(child)
    if (index !== -1) {
      this._children.splice(index, 1)
      child._parent = null
      this._node.removeChild(child._node)
      this.markDirty()
    }
  }

  /**
   * Get child at index.
   *
   * @param {number} index - Child index
   * @returns {YogaNodeWrapper}
   */
  getChild(index) {
    return this._children[index]
  }

  /**
   * Get number of children.
   *
   * @returns {number}
   */
  getChildCount() {
    return this._children.length
  }

  /**
   * Get parent node.
   *
   * @returns {YogaNodeWrapper | null}
   */
  getParent() {
    return this._parent
  }

  // ==========================================================================
  // Layout calculation
  // ==========================================================================

  /**
   * Calculate layout with specified dimensions and direction.
   *
   * @param {number | undefined} width - Available width (undefined = auto)
   * @param {number | undefined} height - Available height (undefined = auto)
   * @param {number} _direction - Layout direction (ignored by Taffy)
   */
  calculateLayout(width = undefined, height = undefined, _direction = 1) {
    const w = width === undefined ? 999999 : width
    const h = height === undefined ? 999999 : height

    this._node.calculateLayout(w, h)
    this._hasNewLayout = true
    this._isDirty = false
  }

  /**
   * Mark node as dirty (needs re-layout).
   */
  markDirty() {
    this._isDirty = true
    if (this._dirtiedFunc) {
      this._dirtiedFunc(this)
    }
  }

  /**
   * Check if node is dirty.
   *
   * @returns {boolean}
   */
  isDirty() {
    return this._isDirty
  }

  /**
   * Check if node has new layout.
   *
   * @returns {boolean}
   */
  hasNewLayout() {
    return this._hasNewLayout
  }

  /**
   * Mark layout as seen (clears hasNewLayout flag).
   */
  markLayoutSeen() {
    this._hasNewLayout = false
  }

  // ==========================================================================
  // Style setters
  // ==========================================================================

  setWidth(width) {
    this._node.setWidth(width)
    this.markDirty()
  }

  setHeight(height) {
    this._node.setHeight(height)
    this.markDirty()
  }

  setMinWidth(minWidth) {
    this._node.setMinWidth(minWidth)
    this.markDirty()
  }

  setMinHeight(minHeight) {
    this._node.setMinHeight(minHeight)
    this.markDirty()
  }

  setMaxWidth(maxWidth) {
    this._node.setMaxWidth(maxWidth)
    this.markDirty()
  }

  setMaxHeight(maxHeight) {
    this._node.setMaxHeight(maxHeight)
    this.markDirty()
  }

  setFlexDirection(direction) {
    this._node.setFlexDirection(direction)
    this.markDirty()
  }

  setJustifyContent(justify) {
    this._node.setJustifyContent(justify)
    this.markDirty()
  }

  setAlignItems(align) {
    this._node.setAlignItems(align)
    this.markDirty()
  }

  setAlignContent(align) {
    this._node.setAlignContent(align)
    this.markDirty()
  }

  setAlignSelf(align) {
    this._node.setAlignSelf(align)
    this.markDirty()
  }

  setFlexWrap(wrap) {
    this._node.setFlexWrap(wrap)
    this.markDirty()
  }

  setFlex(flex) {
    this._node.setFlex(flex)
    this.markDirty()
  }

  setFlexGrow(flexGrow) {
    this._node.setFlexGrow(flexGrow)
    this.markDirty()
  }

  setFlexShrink(flexShrink) {
    this._node.setFlexShrink(flexShrink)
    this.markDirty()
  }

  setFlexBasis(flexBasis) {
    this._node.setFlexBasis(flexBasis)
    this.markDirty()
  }

  setPadding(edge, padding) {
    this._node.setPadding(edge, padding)
    this.markDirty()
  }

  setMargin(edge, margin) {
    this._node.setMargin(edge, margin)
    this.markDirty()
  }

  // ==========================================================================
  // Layout getters
  // ==========================================================================

  getComputedLeft() {
    return this._node.getComputedLeft()
  }

  getComputedTop() {
    return this._node.getComputedTop()
  }

  getComputedRight() {
    return this._node.getComputedRight()
  }

  getComputedBottom() {
    return this._node.getComputedBottom()
  }

  getComputedWidth() {
    return this._node.getComputedWidth()
  }

  getComputedHeight() {
    return this._node.getComputedHeight()
  }

  getComputedLayout() {
    return {
      left: this.getComputedLeft(),
      top: this.getComputedTop(),
      width: this.getComputedWidth(),
      height: this.getComputedHeight(),
      right: this.getComputedRight(),
      bottom: this.getComputedBottom(),
    }
  }

  // ==========================================================================
  // Measure function
  // ==========================================================================

  /**
   * Set measure function for this node.
   *
   * Note: Taffy doesn't support measure functions in the same way as Yoga.
   * This is stored but not currently integrated with layout calculations.
   *
   * @param {Function | null} measureFunc - Measure function
   */
  setMeasureFunc(measureFunc) {
    this._measureFunc = measureFunc
  }

  /**
   * Unset measure function.
   */
  unsetMeasureFunc() {
    this._measureFunc = null
  }

  // ==========================================================================
  // Lifecycle
  // ==========================================================================

  /**
   * Free node resources (no-op in WASM).
   */
  free() {
    this._node.free()
  }

  /**
   * Free node and all children recursively (no-op in WASM).
   */
  freeRecursive() {
    for (const child of this._children) {
      child.freeRecursive()
    }
    this.free()
  }

  /**
   * Reset node to default style.
   */
  reset() {
    this._node.reset()
    this._children = []
    this._parent = null
    this._measureFunc = null
    this._dirtiedFunc = null
    this._isDirty = true
    this._hasNewLayout = false
  }

  /**
   * Copy style from another node.
   *
   * Note: This is a stub - full implementation would copy all style properties.
   *
   * @param {YogaNodeWrapper} _node - Node to copy style from
   */
  copyStyle(_node) {
    // Stub: Full implementation would copy all style properties.
    this.markDirty()
  }

  /**
   * Set dirtied callback.
   *
   * @param {Function | null} dirtiedFunc - Callback when node is dirtied
   */
  setDirtiedFunc(dirtiedFunc) {
    this._dirtiedFunc = dirtiedFunc
  }
}

/**
 * Yoga API.
 *
 * Main export providing factory methods for Config and Node.
 */
const Yoga = {
  /**
   * Initialize Yoga WASM module.
   *
   * @returns {Promise<typeof Yoga>}
   */
  async init() {
    await loadWasm()
    return this
  },

  /**
   * Config factory.
   */
  Config: {
    create() {
      return new YogaConfig()
    },
  },

  /**
   * Node factory.
   */
  Node: {
    create(config = null) {
      return new YogaNodeWrapper(config)
    },
  },

  /**
   * Direction constants.
   */
  DIRECTION_LTR: 1,
  DIRECTION_RTL: 2,
  DIRECTION_INHERIT: 0,
}

export default Yoga

// Export all enums.
export * from './enums.mjs'
