Index: /rollup/dist/es/shared/node-entry.js
===================================================================
--- /rollup/dist/es/shared/node-entry.js
+++ /rollup/dist/es/shared/node-entry.js
@@ -5007,9 +5007,9 @@
                 : [...path1, ...path2];
 };
 
 class LocalVariable extends Variable {
-    constructor(name, declarator, init, 
+    constructor(name, declarator, init,
     /** if this is non-empty, the actual init is this path of this.init */
     initPath, context, kind) {
         super(name);
         this.init = init;
@@ -6458,9 +6458,9 @@
         super.initialise();
         if (this.directive &&
             this.directive !== 'use strict' &&
             this.parent.type === Program$1) {
-            this.scope.context.log(LOGLEVEL_WARN, 
+            this.scope.context.log(LOGLEVEL_WARN,
             // This is necessary, because either way (deleting or not) can lead to errors.
             logModuleLevelDirective(this.directive, this.scope.context.module.id), this.start);
         }
     }
@@ -7759,20 +7759,20 @@
             this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);
         }
     }
 }
-const formatsMaybeAccessDocumentCurrentScript = ['cjs', 'iife', 'umd'];
+const formatsMaybeAccessDocumentCurrentScript = ['iife', 'umd'];
 const accessedMetaUrlGlobals = {
     amd: ['document', 'module', 'URL'],
-    cjs: ['document', 'require', 'URL', DOCUMENT_CURRENT_SCRIPT],
+    cjs: ['require', 'URL', DOCUMENT_CURRENT_SCRIPT],
     es: [],
     iife: ['document', 'URL', DOCUMENT_CURRENT_SCRIPT],
     system: ['module'],
     umd: ['document', 'require', 'URL', DOCUMENT_CURRENT_SCRIPT]
 };
 const accessedFileUrlGlobals = {
     amd: ['document', 'require', 'URL'],
-    cjs: ['document', 'require', 'URL'],
+    cjs: ['require', 'URL'],
     es: [],
     iife: ['document', 'URL'],
     system: ['module', 'URL'],
     umd: ['document', 'require', 'URL']
@@ -7786,9 +7786,9 @@
         : property === 'url'
             ? urlMechanism
             : 'undefined';
 };
-const getFileUrlFromFullPath = (path) => `require('u' + 'rl').pathToFileURL(${path}).href`;
+const getFileUrlFromFullPath = (path) => `require('node:url').pathToFileURL(${path}).href`;
 const getFileUrlFromRelativePath = (path) => getFileUrlFromFullPath(`__dirname + '/${escapeId(path)}'`);
 const getUrlFromDocument = (chunkId, umd = false) => `${umd ? `typeof document === 'undefined' ? location.href : ` : ''}(${DOCUMENT_CURRENT_SCRIPT} && ${DOCUMENT_CURRENT_SCRIPT}.tagName.toUpperCase() === 'SCRIPT' && ${DOCUMENT_CURRENT_SCRIPT}.src || new URL('${escapeId(chunkId)}', document.baseURI).href)`;
 const relativeUrlMechanisms = {
     amd: relativePath => {
@@ -7803,9 +7803,9 @@
     umd: relativePath => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getFileUrlFromRelativePath(relativePath)} : ${getRelativeUrlFromDocument(relativePath, true)})`
 };
 const importMetaMechanisms = {
     amd: getGenericImportMetaMechanism(() => getResolveUrl(`module.uri, document.baseURI`)),
-    cjs: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' ? ${getFileUrlFromFullPath('__filename')} : ${getUrlFromDocument(chunkId)})`),
+    cjs: getGenericImportMetaMechanism(() => `${getFileUrlFromFullPath('__filename')}`),
     iife: getGenericImportMetaMechanism(chunkId => getUrlFromDocument(chunkId)),
     system: (property, { snippets: { getPropertyAccess } }) => property === null ? `module.meta` : `module.meta${getPropertyAccess(property)}`,
     umd: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getFileUrlFromFullPath('__filename')} : ${getUrlFromDocument(chunkId, true)})`)
 };
@@ -9345,9 +9345,9 @@
 		    return segs[segs.length - 2];
 		  }
 
 		  return last;
-		}; 
+		};
 	} (utils));
 	return utils;
 }
 
@@ -17586,9 +17586,9 @@
             // Synthetic namespaces should not hide "regular" exports of the same name
             if (module.info.syntheticNamedExports === name) {
                 continue;
             }
-            const [variable, options] = getVariableForExportNameRecursive(module, name, importerForSideEffects, true, 
+            const [variable, options] = getVariableForExportNameRecursive(module, name, importerForSideEffects, true,
             // We are creating a copy to handle the case where the same binding is
             // imported through different namespace reexports gracefully
             copyNameToModulesMap(searchedNamesAndModules));
             if (module instanceof ExternalModule || options?.indirectExternal) {
@@ -18321,9 +18321,9 @@
                     this.facadeChunkByModule.set(module, this);
                     continue;
                 }
             }
-            const requiredFacades = Array.from(new Set(module.chunkNames.filter(({ isUserDefined }) => isUserDefined).map(({ name }) => name)), 
+            const requiredFacades = Array.from(new Set(module.chunkNames.filter(({ isUserDefined }) => isUserDefined).map(({ name }) => name)),
             // mapping must run after Set 'name' dedupe
             name => ({
                 name
             }));
@@ -19802,9 +19802,9 @@
 }
 function mergeChunks(chunkPartition, minChunkSize, sideEffectAtoms, sizeByAtom) {
     const { small } = chunkPartition;
     for (const mergedChunk of small) {
-        const bestTargetChunk = findBestMergeTarget(mergedChunk, chunkPartition, sideEffectAtoms, sizeByAtom, 
+        const bestTargetChunk = findBestMergeTarget(mergedChunk, chunkPartition, sideEffectAtoms, sizeByAtom,
         // In the default case, we do not accept size increases
         minChunkSize <= 1 ? 1 : Infinity);
         if (bestTargetChunk) {
             const { containedAtoms, correlatedAtoms, modules, pure, size } = mergedChunk;
@@ -19858,9 +19858,9 @@
  * is returned.
  * Merging will not produce cycles if none of the direct non-merged
  * dependencies of a chunk have the other chunk as a transitive dependency.
  */
-function getAdditionalSizeAfterMerge(mergedChunk, targetChunk, 
+function getAdditionalSizeAfterMerge(mergedChunk, targetChunk,
 // The maximum additional unused code size allowed to be added by the merge,
 // taking dependencies into account, needs to be below this number
 currentAdditionalSize, sideEffectAtoms, sizeByAtom) {
     const firstSize = getAdditionalSizeIfNoTransitiveDependencyOrNonCorrelatedSideEffect(mergedChunk, targetChunk, currentAdditionalSize, sideEffectAtoms, sizeByAtom);
Index: /rollup/dist/shared/rollup.js
===================================================================
--- /rollup/dist/shared/rollup.js
+++ /rollup/dist/shared/rollup.js
@@ -1234,9 +1234,9 @@
 		    return segs[segs.length - 2];
 		  }
 
 		  return last;
-		}; 
+		};
 	} (utils));
 	return utils;
 }
 
@@ -8795,9 +8795,9 @@
                 : [...path1, ...path2];
 };
 
 class LocalVariable extends Variable {
-    constructor(name, declarator, init, 
+    constructor(name, declarator, init,
     /** if this is non-empty, the actual init is this path of this.init */
     initPath, context, kind) {
         super(name);
         this.init = init;
@@ -10234,9 +10234,9 @@
         super.initialise();
         if (this.directive &&
             this.directive !== 'use strict' &&
             this.parent.type === parseAst_js.Program) {
-            this.scope.context.log(parseAst_js.LOGLEVEL_WARN, 
+            this.scope.context.log(parseAst_js.LOGLEVEL_WARN,
             // This is necessary, because either way (deleting or not) can lead to errors.
             parseAst_js.logModuleLevelDirective(this.directive, this.scope.context.module.id), this.start);
         }
     }
@@ -11535,20 +11535,20 @@
             this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);
         }
     }
 }
-const formatsMaybeAccessDocumentCurrentScript = ['cjs', 'iife', 'umd'];
+const formatsMaybeAccessDocumentCurrentScript = ['iife', 'umd'];
 const accessedMetaUrlGlobals = {
     amd: ['document', 'module', 'URL'],
-    cjs: ['document', 'require', 'URL', DOCUMENT_CURRENT_SCRIPT],
+    cjs: ['require', 'URL', DOCUMENT_CURRENT_SCRIPT],
     es: [],
     iife: ['document', 'URL', DOCUMENT_CURRENT_SCRIPT],
     system: ['module'],
     umd: ['document', 'require', 'URL', DOCUMENT_CURRENT_SCRIPT]
 };
 const accessedFileUrlGlobals = {
     amd: ['document', 'require', 'URL'],
-    cjs: ['document', 'require', 'URL'],
+    cjs: ['require', 'URL'],
     es: [],
     iife: ['document', 'URL'],
     system: ['module', 'URL'],
     umd: ['document', 'require', 'URL']
@@ -11562,9 +11562,9 @@
         : property === 'url'
             ? urlMechanism
             : 'undefined';
 };
-const getFileUrlFromFullPath = (path) => `require('u' + 'rl').pathToFileURL(${path}).href`;
+const getFileUrlFromFullPath = (path) => `require('node:url').pathToFileURL(${path}).href`;
 const getFileUrlFromRelativePath = (path) => getFileUrlFromFullPath(`__dirname + '/${escapeId(path)}'`);
 const getUrlFromDocument = (chunkId, umd = false) => `${umd ? `typeof document === 'undefined' ? location.href : ` : ''}(${DOCUMENT_CURRENT_SCRIPT} && ${DOCUMENT_CURRENT_SCRIPT}.tagName.toUpperCase() === 'SCRIPT' && ${DOCUMENT_CURRENT_SCRIPT}.src || new URL('${escapeId(chunkId)}', document.baseURI).href)`;
 const relativeUrlMechanisms = {
     amd: relativePath => {
@@ -11579,9 +11579,9 @@
     umd: relativePath => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getFileUrlFromRelativePath(relativePath)} : ${getRelativeUrlFromDocument(relativePath, true)})`
 };
 const importMetaMechanisms = {
     amd: getGenericImportMetaMechanism(() => getResolveUrl(`module.uri, document.baseURI`)),
-    cjs: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' ? ${getFileUrlFromFullPath('__filename')} : ${getUrlFromDocument(chunkId)})`),
+    cjs: getGenericImportMetaMechanism(() => `${getFileUrlFromFullPath('__filename')}`),
     iife: getGenericImportMetaMechanism(chunkId => getUrlFromDocument(chunkId)),
     system: (property, { snippets: { getPropertyAccess } }) => property === null ? `module.meta` : `module.meta${getPropertyAccess(property)}`,
     umd: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getFileUrlFromFullPath('__filename')} : ${getUrlFromDocument(chunkId, true)})`)
 };
@@ -19188,9 +19188,9 @@
             // Synthetic namespaces should not hide "regular" exports of the same name
             if (module.info.syntheticNamedExports === name) {
                 continue;
             }
-            const [variable, options] = getVariableForExportNameRecursive(module, name, importerForSideEffects, true, 
+            const [variable, options] = getVariableForExportNameRecursive(module, name, importerForSideEffects, true,
             // We are creating a copy to handle the case where the same binding is
             // imported through different namespace reexports gracefully
             copyNameToModulesMap(searchedNamesAndModules));
             if (module instanceof ExternalModule || options?.indirectExternal) {
@@ -19814,9 +19814,9 @@
                     this.facadeChunkByModule.set(module, this);
                     continue;
                 }
             }
-            const requiredFacades = Array.from(new Set(module.chunkNames.filter(({ isUserDefined }) => isUserDefined).map(({ name }) => name)), 
+            const requiredFacades = Array.from(new Set(module.chunkNames.filter(({ isUserDefined }) => isUserDefined).map(({ name }) => name)),
             // mapping must run after Set 'name' dedupe
             name => ({
                 name
             }));
@@ -21295,9 +21295,9 @@
 }
 function mergeChunks(chunkPartition, minChunkSize, sideEffectAtoms, sizeByAtom) {
     const { small } = chunkPartition;
     for (const mergedChunk of small) {
-        const bestTargetChunk = findBestMergeTarget(mergedChunk, chunkPartition, sideEffectAtoms, sizeByAtom, 
+        const bestTargetChunk = findBestMergeTarget(mergedChunk, chunkPartition, sideEffectAtoms, sizeByAtom,
         // In the default case, we do not accept size increases
         minChunkSize <= 1 ? 1 : Infinity);
         if (bestTargetChunk) {
             const { containedAtoms, correlatedAtoms, modules, pure, size } = mergedChunk;
@@ -21351,9 +21351,9 @@
  * is returned.
  * Merging will not produce cycles if none of the direct non-merged
  * dependencies of a chunk have the other chunk as a transitive dependency.
  */
-function getAdditionalSizeAfterMerge(mergedChunk, targetChunk, 
+function getAdditionalSizeAfterMerge(mergedChunk, targetChunk,
 // The maximum additional unused code size allowed to be added by the merge,
 // taking dependencies into account, needs to be below this number
 currentAdditionalSize, sideEffectAtoms, sizeByAtom) {
     const firstSize = getAdditionalSizeIfNoTransitiveDependencyOrNonCorrelatedSideEffect(mergedChunk, targetChunk, currentAdditionalSize, sideEffectAtoms, sizeByAtom);
