/**
 * Mock helpers for testing malware detection in Socket CLI.
 * Provides utilities to mock Socket API responses with malware alerts.
 */

import { vi } from 'vitest'

import type { CompactSocketArtifact } from '../src/utils/alert/artifact.mts'

/**
 * Creates a mocked malware package response for testing.
 * This simulates what the Socket API would return for a malicious package.
 */
export function createMalwarePackageResponse(): CompactSocketArtifact {
  return {
    id: '99999999999',
    size: 1024,
    type: 'npm',
    name: 'evil-test-package',
    version: '1.0.0',
    alerts: [
      {
        key: 'QTEST_MALWARE_KEY_12345678901234567890',
        type: 'malware',
        severity: 'critical',
        category: 'supplyChainRisk',
        file: 'evil-test-package-1.0.0/index.js',
        props: {
          id: 999999,
          note: 'This package contains malicious code that attempts to steal credentials and execute remote commands. DO NOT USE.',
        },
        action: 'error',
        fix: {
          type: 'remove',
          description: 'Remove this package immediately and audit your system for compromise.',
        },
      },
      {
        key: 'QTEST_GPTMALWARE_KEY_98765432109876543210',
        type: 'gptMalware',
        severity: 'critical',
        category: 'supplyChainRisk',
        file: 'evil-test-package-1.0.0/index.js',
        props: {
          notes: 'AI analysis detected highly suspicious patterns including credential harvesting, data exfiltration, and backdoor installation. This package poses an extreme security risk.',
          severity: 0.99,
          confidence: 0.98,
        },
        action: 'error',
      },
      {
        key: 'QTEST_NETWORK_ACCESS_KEY_11111111111111111111',
        type: 'networkAccess',
        severity: 'high',
        category: 'supplyChainRisk',
        file: 'evil-test-package-1.0.0/index.js',
        action: 'warn',
      },
    ],
    score: {
      license: 0,
      maintenance: 0,
      overall: 0.01,
      quality: 0,
      supplyChain: 0.01,
      vulnerability: 0,
    },
    batchIndex: 0,
    license: 'UNKNOWN',
    licenseDetails: [],
  }
}

/**
 * Creates a safe package response for testing (no malware).
 */
export function createSafePackageResponse(name: string, version: string): CompactSocketArtifact {
  return {
    id: '12345678',
    size: 512,
    type: 'npm',
    name,
    version,
    alerts: [],
    score: {
      license: 1,
      maintenance: 1,
      overall: 1,
      quality: 1,
      supplyChain: 1,
      vulnerability: 1,
    },
    batchIndex: 0,
    license: 'MIT',
    licenseDetails: [],
  }
}

/**
 * Sets up mocks for Socket SDK to return malware responses.
 * This function should be called in beforeEach hooks.
 */
export function setupMalwareMocks() {
  const mockSetupSdk = vi.fn()
  const mockBatchPackageFetch = vi.fn()
  const mockBatchPackageStream = vi.fn()

  // Mock the SDK setup to return our mocked functions.
  mockSetupSdk.mockResolvedValue({
    ok: true,
    data: {
      batchPackageFetch: mockBatchPackageFetch,
      batchPackageStream: mockBatchPackageStream,
    },
  })

  // Mock batch package fetch to return malware for evil-test-package.
  mockBatchPackageFetch.mockImplementation(async ({ components }) => {
    const results = components.map((component: { purl: string }) => {
      if (component.purl.includes('evil-test-package')) {
        return createMalwarePackageResponse()
      }
      // Return safe package for others.
      const [, name, version] = component.purl.match(/pkg:\w+\/([^@]+)@(.+)/) || []
      return createSafePackageResponse(name || 'unknown', version || '1.0.0')
    })

    return {
      ok: true,
      data: results,
    }
  })

  // Mock batch package stream for streaming responses.
  mockBatchPackageStream.mockImplementation(async function* (purls: string[]) {
    for (const purl of purls) {
      if (purl.includes('evil-test-package')) {
        yield {
          success: true,
          data: createMalwarePackageResponse(),
        }
      } else {
        const [, name, version] = purl.match(/pkg:\w+\/([^@]+)@(.+)/) || []
        yield {
          success: true,
          data: createSafePackageResponse(name || 'unknown', version || '1.0.0'),
        }
      }
    }
  })

  return {
    mockSetupSdk,
    mockBatchPackageFetch,
    mockBatchPackageStream,
  }
}